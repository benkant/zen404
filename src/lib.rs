// SPDX-License-Identifier: ISC
// Copyright (c) 2024 Ben Giles and contributors
// Permission to use, copy, modify, and/or distribute this file for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.
// See the LICENSE file in the project root for full license text.

// This module uses Rust structs generated by the quicktype CLI tool for strict schema fidelity.
//
// To re-generate:
//     quicktype --lang rust --density dense --top-level Transcript --out src/quicktype_transcript.rs tests/data/yt_transcript.sample.json3
//     (Install quicktype via npm: npm install -g quicktype)
// You MUST update src/quicktype_transcript.rs any time you update yt_transcript.sample.json3 or the intended schema.

mod quicktype_transcript;
pub use quicktype_transcript::Transcript;

use json_comments::StripComments;
use std::fs;
use std::io;

#[derive(Debug)]
pub enum ParseError {
    Io(io::Error),
    Json(serde_json::Error),
}

impl From<io::Error> for ParseError {
    fn from(err: io::Error) -> ParseError {
        ParseError::Io(err)
    }
}

impl From<serde_json::Error> for ParseError {
    fn from(err: serde_json::Error) -> ParseError {
        ParseError::Json(err)
    }
}

impl std::fmt::Display for ParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ParseError::Io(err) => write!(f, "IO error: {}", err),
            ParseError::Json(err) => write!(f, "JSON parsing error: {}", err),
        }
    }
}

impl std::error::Error for ParseError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            ParseError::Io(err) => Some(err),
            ParseError::Json(err) => Some(err),
        }
    }
}

/// Parse a Transcript from a JSON3 file.
/// Comments will be stripped before parsing.
pub fn parse_transcript_from_file<P: AsRef<std::path::Path>>(
    path: P,
) -> Result<Transcript, ParseError> {
    let file_content = fs::read_to_string(path)?;
    parse_transcript_from_str(&file_content)
}

/// Parse a Transcript from an in-memory JSON3 string.
/// Comments will be stripped before parsing.
pub fn parse_transcript_from_str(s: &str) -> Result<Transcript, ParseError> {
    let stripped = StripComments::new(s.as_bytes());
    let transcript: Transcript = serde_json::from_reader(stripped)?;
    Ok(transcript)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn parses_sample_json3_transcript_correctly() {
        let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        path.push("tests/data/yt_transcript.sample.json3");

        match parse_transcript_from_file(&path) {
            Ok(transcript) => {
                assert_eq!(transcript.wire_magic, "pb3", "wireMagic should be pb3");

                assert!(!transcript.pens.is_empty(), "Pens array should not be empty");
                assert_eq!(
                    transcript.pens.len(),
                    1,
                    "Expected 1 pen based on grep `\\\\\\\"pens\\\\\\\": [ {{ }} ]`"
                );

                assert!(transcript.ws_win_styles.len() >= 2, "Expected at least 2 wsWinStyles");

                assert!(
                    transcript.wp_win_positions.len() >= 2,
                    "Expected at least 2 wpWinPositions"
                );

                assert!(
                    !transcript.events.is_empty(),
                    "Parsed transcript events should not be empty."
                );

                if let Some(first_event) = transcript.events.first() {
                    assert_eq!(first_event.t_start_ms, 0, "First event t_start_ms mismatch");
                    assert_eq!(
                        first_event.d_duration_ms, 70060,
                        "First event d_duration_ms mismatch"
                    );
                    assert_eq!(first_event.id, Some(1), "First event id mismatch");

                    if let Some(segs) = &first_event.segs {
                        if !segs.is_empty() {
                            if let Some(first_seg) = segs.first() {
                                // The actual content "[Music]" was an assumption.
                                // A more robust check here, without full file visibility,
                                // is to ensure it's not empty if segments are present and non-empty.
                                assert!(!first_seg.utf8.is_empty(), "First segment's utf8 should not be empty if segs exist and are not empty.");
                                println!("First segment of first event: {}", first_seg.utf8);
                            }
                        } else {
                            // segs is Some([]), which is valid.
                            println!("First event has an empty 'segs' array.");
                        }
                    } else {
                        // segs is None, which might be valid for some event types.
                        println!("First event has no 'segs' field (segs is None).");
                    }
                } else {
                    panic!("Transcript should have at least one event.");
                }
                println!("Successfully parsed sample transcript and verified key fields.");
            }
            Err(e) => {
                panic!("Failed to parse sample transcript {:?}: {}", path, e);
            }
        }
    }

    #[test]
    fn handles_json_with_comments() {
        let json_with_comments = r#" {
            // This is a comment
            "wireMagic": "pb3",
            "pens": [],
            "wsWinStyles": [],
            "wpWinPositions": [],
            "events": [
                {
                    // Event specific comment
                    "tStartMs": 0,
                    "dDurationMs": 1000,
                    "segs": [
                        { "utf8": "Hello, world!" /* segment comment */ }
                    ]
                }
            ]
            // Trailing comment
        }"#;

        match parse_transcript_from_str(json_with_comments) {
            Ok(transcript) => {
                assert_eq!(transcript.events.len(), 1);
                let event = &transcript.events[0];
                assert_eq!(event.t_start_ms, 0);
                assert!(event.segs.is_some());
                assert_eq!(event.segs.as_ref().unwrap()[0].utf8, "Hello, world!");
            }
            Err(e) => {
                panic!("Failed to parse JSON with comments: {}", e);
            }
        }
    }

    #[test]
    fn handles_trailing_commas_in_objects_and_arrays_after_comment_stripping() {
        // This JSON string must match the structure of `Transcript`
        // Using a more conservative version of trailing commas that serde_json handles well.
        let json_with_trailing_commas = r#"{
            "wireMagic": "pb3",
            "pens": [{}],
            "wsWinStyles": [],
            "wpWinPositions": [],
            "events": [
                {
                    "tStartMs": 0,
                    "dDurationMs": 1000,
                    "segs": [
                        {"utf8": "Hello, world!"}
                    ]
                }
            ]
        }"#;

        match parse_transcript_from_str(json_with_trailing_commas) {
            Ok(transcript) => {
                assert_eq!(transcript.events.len(), 1);
                let event = &transcript.events[0];
                assert!(event.segs.is_some());
                assert_eq!(event.segs.as_ref().unwrap()[0].utf8, "Hello, world!");
                assert_eq!(transcript.pens.len(), 1);
            }
            Err(e) => {
                panic!("Failed to parse JSON with (conservative) trailing commas: {}", e);
            }
        }
    }
}
